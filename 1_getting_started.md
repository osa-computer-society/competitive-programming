# Getting Started

## What is competitive programming?

If you've ever written a math contest, chances are you understand the thrill of digging your teeth into a challenging logical problem all the way through to the end.

If that sounds totally nerdy and uninteresting to you, well, bear with us â€” after seeing your algorithm pass all the test cases for the first time, we hope you'll be just as excited.

At its core, **competitive programming is really just about solving a set of problems in a set period of time.**

Some of these problems might have important real-world applications, like finding the shortest path between two locations or encrypting messages using error-correcting codes, while others might be more abstract extensions of theoretical concepts.

In the end, though, all you're doing is **figuring out how to transform a given input into a given output,** based on the demands of the question.

As for the actual structure of competitions, most sites use an **online judge:**

1. You upload your code to the judge
2. It runs your code by inputting several **test cases**
   - Different judges do this in different ways, but usually this will be directly through standard input. Some will ask you to read from a file, such as USACO.
3. It tells you if it produced the correct result or not. If your code's output matches the expected output for every test case, you've solved the problem!

Different judges will give different details if you fail: some will tell you if your code crashed, some will actually show you the test cases you failed on, while some will just give you a big fat red X.

## Why competitive programming?

First of all, why not take the opportunity to **improve yourself and learn some new things?**

Learning algorithms comes with great benefits to your problem-solving and logical thinking skills, et cetera et cetera, the same arguments that apply to learning contest maths or solving a Rubik's cube.

Secondly, like we mentioned above, **solving problems is a lot of fun!**

It might seem like a difficult and time-consuming way to get your dose of dopamine, but would you rather:

  1. Doomscroll all day on Instagram and Facebook with costs to your mental health
OR
  1. Put in time and effort into a valuable skill and see yourself learn and grow over time?

Finally, for all of you pragmatists out there, most of the big tech companies, e.g. FAANG (Facebook, Amazon, Apple, Netflix, Google), **use questions similar to the ones you'll see here on their screening interviews.** These interviews are notoriously difficult, so the sooner you get started learning the concepts that'll show up, the better!

## Which language should I use?

Firstly, you'll need to check, which languages *can* I use? Different competitions support different languages. Typically, **C, C++, Python, and Java** are the most commonly used and supported languages, while Google Kick Start and Kattis allow just about any language you can name.

If you're entirely new to programming, **Python** is a very beginner-friendly language that's probably the easiest one to learn and get started with.

If you have experience with programming and are looking to use the tools of the trade, **C++** is the most popular language for competitive programming because of its **speed** and great **standard library,** which contains many builtin data structures.

We're still working on adding solutions in other supported languages. If we're missing one you'd like to see, [add it yourself](README.md#Contributing)!

## Tips and tricks

1. **Think clearly.** Don't rush into writing code before you're confident the logic for your algorithm is correct.

2. **Go for partial marks.** We'll get more into what this means later, but most problems will give you partial marks if your solution works for certain input sizes. Quite often, you can solve the first test case by implementing a brute-force solution, so **go for that first** rather than getting *no* points aiming for perfection. The simple solution might also give you some clues on how to improve your algorithm.

Oh, and, of course, **practice, practice, practice.**
